# Изучение Git - конспекты

Первый абзац про проект предисловие

## Основные команды работы с Git на компе

cd - переход в категорию
pwd - вывести текущую категорию местонахождения
ls - вывести содержимое в категории
cd ~ - переход в корень
mkdir - создание папки (категории)
touch - создание файла с любым раширением внутри категории
(можно создать файл по маршруту - тогда прописывается путь + название файла)
rm - удаление файла
rmdir - удаление пустой категории
rm -r - удалить всю категорию со всем содержимым 
cat +название файла - прочитать файл (обычно формат txt или аналог)

**Горячие клавиши**
Tab - позволяет дописывать по первым буквам
Стрелки вверх-вниз - выведет прошлые команды из памяти

**Создание репозитория - локальный депозиторий**

Переходим в папку, которую надо объявить репозиторием
Запускаем команду

```
git init
```

Объявление произошло

Можно разгититить, тогда: 

```
rm -rf .git
```

Прим: Эта операция должна происходить в корне категории, которая была обьявлена репозиторием

git status - текущее состояние проекта
git log - все совершенные события

**Создание коммита**

git add - добавление 

Пример:

```
git add file-1.txt
git add file-2.txt
```

Или добавить все споком

```
git add --all
```

Таким образом мы привязали файлы к учету в репозитории - теперь они отслеживаются.
Чтобы измененный файл получил коммент по изменениям, используем git commit:


git commit -m "Comment to change" - в кавычках коммент

При тесте у меня была ошибка. Суть такая. Измененный файл, даже уже созданный и привязанный, но измененый, надо снова привязать. То есть создаем снова пару git add && git commit -m

```
git add file-1.txt 
git commit -m "Изменение в файле file-1.txt"
```

## Основные команды Git для работы с удаленным хранилищем типа GitHub

Начальная задача: привязать локальный репозиторий к удаленному хранилищу GitHub

1. Создаем аккаунт на GitHub. Сразу создаем удаленный репозиторий на нем с каким-то названием.
2. Создаем ssh пароли на компе (пара приватный и публичный, публичный с расширением .pub, дальше будем использовать только его). Добавление на GitHub и привязка.
3. Связываем репозитории 

### Шпаргалка для Шага 1

Мой акк на ГитХаб: 

https://github.com/jiicodda/ 

(имя пользователя в конце)

Там можно пройти в репозитории (Repositories). Обображаются текущиее или нажать зеленую кнопку Add. Обьявлем название и указываем: публичный или приватный.

### Создание ssh паролей 

#### Создание ssh паролей на локальном устройстве

Возвращаемся к действиям по настройке локального поля. Идем в корень и вызываем генерацию ключа ssh

```
cd ~
ssh-keygen -t ed25519 -C "myemail@gmail.com"
```

Предварительно можно проверить наличие существующих (обычно в папке /.ssh/)

```
ls -la .ssh/
```

Прим. Если генерации ssh-keygen по шировке ed25519 не произошла, тогда:

```
ssh-keygen -t rsa -b 4096 -C "myemail@gmail.com"
```

----
Внимание! В уроке не указано, но нужно привязать агента, который будет следить за ключами:

```
eval "$(ssh-agent -s)"
```

Агент получает свой идентификатор pid
Добавляем ему приватный ключ:

```
ssh-add -K ~/.ssh/id_ed25519
```

----

#### Добавление ключа ssh в GitHub и привязываем

Settings > SSH and GPG keys 

SSH Keys > New SSH Key

В поле добавляем копираванный ключ (содержимое .pub) 

Чтобы проверить соединение, идем в консоль, команда:

```
ssh -T git@github.com
```

Если первый раз, выведет сообщение, ответить yes

### Связываем репозитории 

Локально перейти в репозиторий (cd путь/репозитория), далее команда:

```
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git 
```

Чтобы убедиться, что связаны:

```
git remote -v
```

## Синхронизация локального и удаленного репозиториев

В корне локального репозитория:

```
git push -u origin master
```

Для первого раза -u, далее просто git push origin
Master может называться Main (это обозначение главной ветки, оно дается по умолчанию)

Чтобы перекинуть отредаченный заново файл (например, этот - README.md), возвращаемся к добавлению коммита, а потом выполняем заталкивание (push) на удаленное хранилище:

```
git add README.md
git commit -m 'Перекидывание отредаченного файла README.md'
git push origin master
```

## Хеш и хеширование

Хеш - уникальная комбинация букв и цифр, служащая своего рода отпечатком для состояния коммита в репозитории. Как только происходит какое-либо изменение, отпечаток (хеш) сразу меняется.
Хеш является идеальным идентификатором для любых изменений.

Хеш отображается в логе (журнал действий)

Вызвать лог:

```
git log
```

Вызвать сокращенный лог:

```
git log --oneline
```

## HEAD

HEAD содержится в директории .git/ 
HEAD является синонимом последнего хеша, тк содержит ссылку (ссылку на ссылку) на него.
Посмотреть HEAD можно запросами:

```
cd .git/
cat HEAD
cat refs/heads/master 
```

Последнее - ссылка из HEAD

## Статусы файлов

**Untracked** - неотслеживаемый (Git не следит за ним, хотя файл добавлен и физически существует в репозитории)

untracked + git add = tracked, staged

**Modified** - измененный (измененный, но еще без учета этих изменений)

modified + git add = staged

**Staged** - подготовленный (отслеживаемый, готов к закомичиванию)

## Оформление коммитов

Комииты - до 72 символов (в короткий лог больше не помещается), максимально информативности.

Может быть использован номер задачи №123 или  с абревиатурой, характеризующий область проекта, напр, РЛ-123.

Может быть применено указание характера действия: новое/фикс и тд.

## Восстановление - откатывание

### Unstaged - вернуть статус файла

Код для файла example.txt:

```
git restore --staged examle.txt
```

### Откатить коммит

По логу находим нужный коммит, до точки состояния которого нужно сделать откат (откат произойдет на все файлы)

В корне репозитория вызываем короткий лог и по хешу делаем возврат/откат

```
git log --oneline
abc123e (HEAD->master, origin/master) Добавление новой инфы в README начиная с хеша
bce1237 Перекидывание отредаченного файла README.md
vcf567f Change2
11er123 Добавление файла README.md и удаление readme.txt
```

Откат до состояния Change2

```
git reset --hard vcf567f
HEAD is now at vcf567f Change2
```

Что произошло? README.md полностью очистился, как был в состоянии только созданный. Однако добавленный позже example.txt файл по-прежнему существует (тоже пустой, он и был пустой), однако вошел в статус untracked, те. неучитываемым, хотя был staged.

Процесс отката просто режет цепочку модификаций, которая происходила после выбранного хеша (более поздние коммиты потеряются!), хотя вероятно оставляет созданные файлы (пустыми?).

С откатом нужна аккуратность: откатанное восстановлению не подлежит (можно сделать дубликаты по текущим файлам и уже только потом откатывать - так сделала я с записями README).

----
Прим. Чтобы откатить изменения в файле, который не хотели менять и который еще не добавлен в staged, выполняем:

```
git restore myfile.txt
```

Если в списке файлов на отправку коммита есть такой. который надо НЕ прикреплять (после git add), тогда

```
git restore --staged deletefile.txt
```

## Сравнение по изменениям в файле

За сравнение отвечает команда git diff (сокр от англ. разница). Надо пройти к файлу, если он в статусе modified (измененный), можно увидеть эти изменения, вызовом git diff

```
git status teremok.txt
.....modified.....
git diff 
```

Общая команда git diff может быть применена только к файлам, которые не были проиндексированы или закоммичены.

Дальше появятся строки сравнения, где ---a - начальный файл, +++b - тот же файл, но измененный

```
...index...
---a/teremok.txt
+++b/teremok.txt
```

Далее идет строка, показывающая какие строки сравнивались (порядковый номер), оформлена в двойные @@. Если файл большой, то разброс строк окружения (контекст) порядка 10: по 5 выше, и 5 ниже.

```
@@ -1,2 +1,2 @@
```

Далее сами изменения ("-" - удаление, "+" - добавление):

```
Теремок стоит, и в нем
-никого нет
+Мышка-норушка
```

## Сопоставление коммитов

### Запись в файл из консоли

Пишем командой echo 'Какой-то текст' и направляем в файл двумя правыми стрелками, знак больше >>. 
Если будет одинарная стрелка >, то произойдет перезапись файла на новое содержимое, а не добавление, как в первом случае.

```
echo 'Какой-то текст' >> teremok.txt
```

### Сопоставление и сравнение

Дальше мы записали несколько строк в теремок и закоммичили каждую из них. Чтобы сравнить состояние теремка попробуем взять первый и последний хехи из лога,
git log --oneline
Сопоставим/сравним произошедшие изменения между двумя крайними хешами (между ними еще несколько)

```
git diff b55bb70 HEAD
```

Здесь не нашлось зацепок (теремок был разрушен до этого). Идем дальше, берем второй сверху коммит (хеш), так же сравниваем:

```
git diff b55bb70 5bb2619
```

## Игнорирование файлов в Git

.gitignore - специальный файл (по типу .htaccess на сатйах), в котором прописываются правила для игнорирования файлов или даже папок. 
Такие файлы/папки не будут попадать в git status. Чтобы вывести в статусе игнорируемые, есть команда git status --ignored.

Пример записей в .gitignore

```
# игнорировать все JPEG-файлы
*.jpeg

# но только не мем с Doge
!doge.jpeg 

# игнорировать все файлы в каталоге build
build/

# игнорировать все .log файлы
*.log

# не игнорировать *.log файлы в examples
# потому что это пример для документации
!examples/**/*.log 

# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt 

# игнорировать в диапазоне [a-z]
newfile[a-z].txt
```

Пример файла .gitignore, если нужно игнорировать все (временные) файлы, кроме нужных:

```
# игнорировать все файлы
**

# кроме .tex и .pdf
!**.tex
!**.pdf 
```